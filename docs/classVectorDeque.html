<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Vector Deque: VectorDeque&lt; DataType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Vector Deque
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classVectorDeque-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">VectorDeque&lt; DataType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code><a class="el" href="classVectorDeque.html" title="VectorDeque satisfies the resource constraints typically expected of both Vectors and Deques...">VectorDeque</a></code> satisfies the resource constraints typically expected of both Vectors and Deques.  
 <a href="classVectorDeque.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="VectorDeque_8hpp_source.html">VectorDeque.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a14c9e8124611465c5aec6687b9c18a4b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a14c9e8124611465c5aec6687b9c18a4b"></a>
typedef IteratorBase<br class="typebreak"/>
&lt; <a class="el" href="classVectorDeque.html">VectorDeque</a>, DataType, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorDeque.html#a14c9e8124611465c5aec6687b9c18a4b">Iterator</a></td></tr>
<tr class="memdesc:a14c9e8124611465c5aec6687b9c18a4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutable iterator for <code><a class="el" href="classVectorDeque.html" title="VectorDeque satisfies the resource constraints typically expected of both Vectors and Deques...">VectorDeque</a></code>s. <br/></td></tr>
<tr class="separator:a14c9e8124611465c5aec6687b9c18a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cfe4fc61668a1213c99e052450297e6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5cfe4fc61668a1213c99e052450297e6"></a>
typedef IteratorBase&lt; const <br class="typebreak"/>
<a class="el" href="classVectorDeque.html">VectorDeque</a>, const DataType, <br class="typebreak"/>
false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorDeque.html#a5cfe4fc61668a1213c99e052450297e6">ConstIterator</a></td></tr>
<tr class="memdesc:a5cfe4fc61668a1213c99e052450297e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Immutable iterator for <code><a class="el" href="classVectorDeque.html" title="VectorDeque satisfies the resource constraints typically expected of both Vectors and Deques...">VectorDeque</a></code>s. <br/></td></tr>
<tr class="separator:a5cfe4fc61668a1213c99e052450297e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c7645ed21181c82fd1837362a1e5145"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c7645ed21181c82fd1837362a1e5145"></a>
typedef IteratorBase<br class="typebreak"/>
&lt; <a class="el" href="classVectorDeque.html">VectorDeque</a>, DataType, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorDeque.html#a6c7645ed21181c82fd1837362a1e5145">ReverseIterator</a></td></tr>
<tr class="memdesc:a6c7645ed21181c82fd1837362a1e5145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutable reverse iterator for <code><a class="el" href="classVectorDeque.html" title="VectorDeque satisfies the resource constraints typically expected of both Vectors and Deques...">VectorDeque</a></code>s. <br/></td></tr>
<tr class="separator:a6c7645ed21181c82fd1837362a1e5145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a291aa5e53d483276367327acb93f3846"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a291aa5e53d483276367327acb93f3846"></a>
typedef IteratorBase&lt; const <br class="typebreak"/>
<a class="el" href="classVectorDeque.html">VectorDeque</a>, const DataType, <br class="typebreak"/>
true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorDeque.html#a291aa5e53d483276367327acb93f3846">ConstReverseIterator</a></td></tr>
<tr class="memdesc:a291aa5e53d483276367327acb93f3846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Immutable reverse iterator for <code><a class="el" href="classVectorDeque.html" title="VectorDeque satisfies the resource constraints typically expected of both Vectors and Deques...">VectorDeque</a></code>s. <br/></td></tr>
<tr class="separator:a291aa5e53d483276367327acb93f3846"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6ccd352013e04ac9b27651028481ff9c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorDeque.html#a6ccd352013e04ac9b27651028481ff9c">VectorDeque</a> ()  throw ()</td></tr>
<tr class="memdesc:a6ccd352013e04ac9b27651028481ff9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <code><a class="el" href="classVectorDeque.html" title="VectorDeque satisfies the resource constraints typically expected of both Vectors and Deques...">VectorDeque</a></code> with a default initial capacity.  <a href="#a6ccd352013e04ac9b27651028481ff9c">More...</a><br/></td></tr>
<tr class="separator:a6ccd352013e04ac9b27651028481ff9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d6b83cb5d9fb65d6ac1ddfa6833205"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorDeque.html#a77d6b83cb5d9fb65d6ac1ddfa6833205">VectorDeque</a> (const size_t capacity)  throw ()</td></tr>
<tr class="memdesc:a77d6b83cb5d9fb65d6ac1ddfa6833205"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <code><a class="el" href="classVectorDeque.html" title="VectorDeque satisfies the resource constraints typically expected of both Vectors and Deques...">VectorDeque</a></code> with the given initial capacity.  <a href="#a77d6b83cb5d9fb65d6ac1ddfa6833205">More...</a><br/></td></tr>
<tr class="separator:a77d6b83cb5d9fb65d6ac1ddfa6833205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae86351d1ecec0183193144844518a971"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorDeque.html#ae86351d1ecec0183193144844518a971">VectorDeque</a> (const <a class="el" href="classVectorDeque.html">VectorDeque</a> &amp;that)  throw ()</td></tr>
<tr class="memdesc:ae86351d1ecec0183193144844518a971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-temporary copy constructor.  <a href="#ae86351d1ecec0183193144844518a971">More...</a><br/></td></tr>
<tr class="separator:ae86351d1ecec0183193144844518a971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa05f563b1148c66067be9a796cfaed13"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorDeque.html#aa05f563b1148c66067be9a796cfaed13">VectorDeque</a> (<a class="el" href="classVectorDeque.html">VectorDeque</a> &amp;&amp;that)  throw ()</td></tr>
<tr class="memdesc:aa05f563b1148c66067be9a796cfaed13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Temporary copy constructor.  <a href="#aa05f563b1148c66067be9a796cfaed13">More...</a><br/></td></tr>
<tr class="separator:aa05f563b1148c66067be9a796cfaed13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be7a91c8d970e4dacce3500116b6f06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVectorDeque.html">VectorDeque</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorDeque.html#a8be7a91c8d970e4dacce3500116b6f06">operator=</a> (const <a class="el" href="classVectorDeque.html">VectorDeque</a> &amp;that)  throw ()</td></tr>
<tr class="memdesc:a8be7a91c8d970e4dacce3500116b6f06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-temporary assignment.  <a href="#a8be7a91c8d970e4dacce3500116b6f06">More...</a><br/></td></tr>
<tr class="separator:a8be7a91c8d970e4dacce3500116b6f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a42da54a15e4f0b4e9f9430e2278a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVectorDeque.html">VectorDeque</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorDeque.html#a80a42da54a15e4f0b4e9f9430e2278a2">operator=</a> (<a class="el" href="classVectorDeque.html">VectorDeque</a> &amp;&amp;that)  throw ()</td></tr>
<tr class="memdesc:a80a42da54a15e4f0b4e9f9430e2278a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Temporary assignment.  <a href="#a80a42da54a15e4f0b4e9f9430e2278a2">More...</a><br/></td></tr>
<tr class="separator:a80a42da54a15e4f0b4e9f9430e2278a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0595132279942b754d035d1e2fedbacb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorDeque.html#a0595132279942b754d035d1e2fedbacb">operator==</a> (const <a class="el" href="classVectorDeque.html">VectorDeque</a> &amp;that) const   throw ()</td></tr>
<tr class="memdesc:a0595132279942b754d035d1e2fedbacb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if <code>*this</code> is equal to another <code><a class="el" href="classVectorDeque.html" title="VectorDeque satisfies the resource constraints typically expected of both Vectors and Deques...">VectorDeque</a></code>.  <a href="#a0595132279942b754d035d1e2fedbacb">More...</a><br/></td></tr>
<tr class="separator:a0595132279942b754d035d1e2fedbacb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab14f8f936e72e47a71b6345b6e2ee5b1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorDeque.html#ab14f8f936e72e47a71b6345b6e2ee5b1">operator!=</a> (const <a class="el" href="classVectorDeque.html">VectorDeque</a> &amp;that) const   throw ()</td></tr>
<tr class="memdesc:ab14f8f936e72e47a71b6345b6e2ee5b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if <code>*this</code> is not equal to another <a class="el" href="classVectorDeque.html" title="VectorDeque satisfies the resource constraints typically expected of both Vectors and Deques...">VectorDeque</a>.  <a href="#ab14f8f936e72e47a71b6345b6e2ee5b1">More...</a><br/></td></tr>
<tr class="separator:ab14f8f936e72e47a71b6345b6e2ee5b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c554dd6085326d0054c32736059654a"><td class="memItemLeft" align="right" valign="top">DataType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorDeque.html#a1c554dd6085326d0054c32736059654a">operator[]</a> (const size_t index) const </td></tr>
<tr class="memdesc:a1c554dd6085326d0054c32736059654a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the element at <code>index</code>.  <a href="#a1c554dd6085326d0054c32736059654a">More...</a><br/></td></tr>
<tr class="separator:a1c554dd6085326d0054c32736059654a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f1a6f951f10d2dbb0a2d4ab37d3df1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorDeque.html#a77f1a6f951f10d2dbb0a2d4ab37d3df1">operator std::string</a> () const   throw ()</td></tr>
<tr class="memdesc:a77f1a6f951f10d2dbb0a2d4ab37d3df1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives a human-readable representation of <code>*this</code>.  <a href="#a77f1a6f951f10d2dbb0a2d4ab37d3df1">More...</a><br/></td></tr>
<tr class="separator:a77f1a6f951f10d2dbb0a2d4ab37d3df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6627a3c5f96e0a597ca4b497789e2dbb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorDeque.html#a6627a3c5f96e0a597ca4b497789e2dbb">add</a> (const DataType &amp;element)  throw ()</td></tr>
<tr class="memdesc:a6627a3c5f96e0a597ca4b497789e2dbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add <code>element</code> to the back of <code>*this</code>.  <a href="#a6627a3c5f96e0a597ca4b497789e2dbb">More...</a><br/></td></tr>
<tr class="separator:a6627a3c5f96e0a597ca4b497789e2dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac600744ac03b32391ce2b3326811944f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorDeque.html#ac600744ac03b32391ce2b3326811944f">addAll</a> (const DataType *const elements, const size_t length)  throw ()</td></tr>
<tr class="memdesc:ac600744ac03b32391ce2b3326811944f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an array of elements to the back of <code>*this</code>.  <a href="#ac600744ac03b32391ce2b3326811944f">More...</a><br/></td></tr>
<tr class="separator:ac600744ac03b32391ce2b3326811944f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a146d4e11742a18062ea3e9e8dd75769f"><td class="memTemplParams" colspan="2">template&lt;class IteratorType &gt; </td></tr>
<tr class="memitem:a146d4e11742a18062ea3e9e8dd75769f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVectorDeque.html#a146d4e11742a18062ea3e9e8dd75769f">addAll</a> (IteratorType <a class="el" href="classVectorDeque.html#a2f16427750643789ac9bddc8337ec702">begin</a>, IteratorType <a class="el" href="classVectorDeque.html#a3fe1250d2f55a3208ac1a2c8597ca4ed">end</a>)  throw ()</td></tr>
<tr class="memdesc:a146d4e11742a18062ea3e9e8dd75769f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a collection of elements to the back of <code>*this</code>.  <a href="#a146d4e11742a18062ea3e9e8dd75769f">More...</a><br/></td></tr>
<tr class="separator:a146d4e11742a18062ea3e9e8dd75769f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97fd51c98bfeccbaf7b5fa24c3ca2f42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorDeque.html#a97fd51c98bfeccbaf7b5fa24c3ca2f42">addAllFirst</a> (const DataType *const elements, const size_t length)  throw ()</td></tr>
<tr class="memdesc:a97fd51c98bfeccbaf7b5fa24c3ca2f42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an array of elements to the front of <code>*this</code>.  <a href="#a97fd51c98bfeccbaf7b5fa24c3ca2f42">More...</a><br/></td></tr>
<tr class="separator:a97fd51c98bfeccbaf7b5fa24c3ca2f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe87b9cd1769bb101cc024f8f7883502"><td class="memTemplParams" colspan="2">template&lt;class IteratorType &gt; </td></tr>
<tr class="memitem:afe87b9cd1769bb101cc024f8f7883502"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVectorDeque.html#afe87b9cd1769bb101cc024f8f7883502">addAllFirst</a> (IteratorType <a class="el" href="classVectorDeque.html#a2f16427750643789ac9bddc8337ec702">begin</a>, IteratorType <a class="el" href="classVectorDeque.html#a3fe1250d2f55a3208ac1a2c8597ca4ed">end</a>)  throw ()</td></tr>
<tr class="memdesc:afe87b9cd1769bb101cc024f8f7883502"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a collection of elements to the front of <code>*this</code>.  <a href="#afe87b9cd1769bb101cc024f8f7883502">More...</a><br/></td></tr>
<tr class="separator:afe87b9cd1769bb101cc024f8f7883502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af28118e77d946e21445f460ca951d983"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorDeque.html#af28118e77d946e21445f460ca951d983">addFirst</a> (const DataType &amp;element)  throw ()</td></tr>
<tr class="memdesc:af28118e77d946e21445f460ca951d983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add <code>element</code> to the front of <code>*this</code>.  <a href="#af28118e77d946e21445f460ca951d983">More...</a><br/></td></tr>
<tr class="separator:af28118e77d946e21445f460ca951d983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f16427750643789ac9bddc8337ec702"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVectorDeque.html#a14c9e8124611465c5aec6687b9c18a4b">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorDeque.html#a2f16427750643789ac9bddc8337ec702">begin</a> ()  throw ()</td></tr>
<tr class="memdesc:a2f16427750643789ac9bddc8337ec702"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator pointing to the first element of <code>*this</code>.  <a href="#a2f16427750643789ac9bddc8337ec702">More...</a><br/></td></tr>
<tr class="separator:a2f16427750643789ac9bddc8337ec702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab50b3786dae9b81ebd8938e6e70bb02e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVectorDeque.html#a5cfe4fc61668a1213c99e052450297e6">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorDeque.html#ab50b3786dae9b81ebd8938e6e70bb02e">cbegin</a> () const   throw ()</td></tr>
<tr class="memdesc:ab50b3786dae9b81ebd8938e6e70bb02e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a constant iterator pointing to the first element of <code>*this</code>.  <a href="#ab50b3786dae9b81ebd8938e6e70bb02e">More...</a><br/></td></tr>
<tr class="separator:ab50b3786dae9b81ebd8938e6e70bb02e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f86389895243f392ceabe443203e32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVectorDeque.html#a5cfe4fc61668a1213c99e052450297e6">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorDeque.html#a77f86389895243f392ceabe443203e32">cend</a> () const   throw ()</td></tr>
<tr class="memdesc:a77f86389895243f392ceabe443203e32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator past the last element of <code>*this</code>.  <a href="#a77f86389895243f392ceabe443203e32">More...</a><br/></td></tr>
<tr class="separator:a77f86389895243f392ceabe443203e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afac9474353f64902fccb648c537e652f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorDeque.html#afac9474353f64902fccb648c537e652f">clear</a> ()  throw ()</td></tr>
<tr class="memdesc:afac9474353f64902fccb648c537e652f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all elements from <code>*this</code>.  <a href="#afac9474353f64902fccb648c537e652f">More...</a><br/></td></tr>
<tr class="separator:afac9474353f64902fccb648c537e652f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0cbf3779a0ea9be8bbfd2409eba889f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorDeque.html#ae0cbf3779a0ea9be8bbfd2409eba889f">contains</a> (const DataType &amp;element) const   throw ()</td></tr>
<tr class="memdesc:ae0cbf3779a0ea9be8bbfd2409eba889f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check to see if <code>element</code> is contained in <code>*this</code>.  <a href="#ae0cbf3779a0ea9be8bbfd2409eba889f">More...</a><br/></td></tr>
<tr class="separator:ae0cbf3779a0ea9be8bbfd2409eba889f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a1250984dcf602e225ecbe10d7cfc9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorDeque.html#a42a1250984dcf602e225ecbe10d7cfc9">copyToArray</a> (DataType *const target) const   throw ()</td></tr>
<tr class="memdesc:a42a1250984dcf602e225ecbe10d7cfc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the contents of <code>*this</code> to <code>target</code>.  <a href="#a42a1250984dcf602e225ecbe10d7cfc9">More...</a><br/></td></tr>
<tr class="separator:a42a1250984dcf602e225ecbe10d7cfc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6577db57d37cc36ce00060baa2abfef6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVectorDeque.html#a291aa5e53d483276367327acb93f3846">ConstReverseIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorDeque.html#a6577db57d37cc36ce00060baa2abfef6">crbegin</a> () const   throw ()</td></tr>
<tr class="memdesc:a6577db57d37cc36ce00060baa2abfef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a constant reverse iterator pointing to the last element of <code>*this</code>.  <a href="#a6577db57d37cc36ce00060baa2abfef6">More...</a><br/></td></tr>
<tr class="separator:a6577db57d37cc36ce00060baa2abfef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac13f397fa78185ae34fc14751ab720"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVectorDeque.html#a291aa5e53d483276367327acb93f3846">ConstReverseIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorDeque.html#abac13f397fa78185ae34fc14751ab720">crend</a> () const   throw ()</td></tr>
<tr class="memdesc:abac13f397fa78185ae34fc14751ab720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator past the last element of <code>*this</code>.  <a href="#abac13f397fa78185ae34fc14751ab720">More...</a><br/></td></tr>
<tr class="separator:abac13f397fa78185ae34fc14751ab720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe1250d2f55a3208ac1a2c8597ca4ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVectorDeque.html#a14c9e8124611465c5aec6687b9c18a4b">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorDeque.html#a3fe1250d2f55a3208ac1a2c8597ca4ed">end</a> ()  throw ()</td></tr>
<tr class="memdesc:a3fe1250d2f55a3208ac1a2c8597ca4ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator past the last element of <code>*this</code>.  <a href="#a3fe1250d2f55a3208ac1a2c8597ca4ed">More...</a><br/></td></tr>
<tr class="separator:a3fe1250d2f55a3208ac1a2c8597ca4ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a301ac89ba3198559c65bd7ff18f4b107"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorDeque.html#a301ac89ba3198559c65bd7ff18f4b107">find</a> (const DataType &amp;element) const   throw ()</td></tr>
<tr class="memdesc:a301ac89ba3198559c65bd7ff18f4b107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check to see where <code>element</code> is located in <code>*this</code>.  <a href="#a301ac89ba3198559c65bd7ff18f4b107">More...</a><br/></td></tr>
<tr class="separator:a301ac89ba3198559c65bd7ff18f4b107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1685429a5556997348d6cf155f499fcd"><td class="memItemLeft" align="right" valign="top">DataType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorDeque.html#a1685429a5556997348d6cf155f499fcd">fromBack</a> (const size_t index) const </td></tr>
<tr class="memdesc:a1685429a5556997348d6cf155f499fcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the element at <code>index</code> starting from the last element.  <a href="#a1685429a5556997348d6cf155f499fcd">More...</a><br/></td></tr>
<tr class="separator:a1685429a5556997348d6cf155f499fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d49f96833f4d6664159a596c3c361be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorDeque.html#a8d49f96833f4d6664159a596c3c361be">insert</a> (const DataType &amp;element, const size_t before)</td></tr>
<tr class="memdesc:a8d49f96833f4d6664159a596c3c361be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert <code>element</code> before <code>before</code>.  <a href="#a8d49f96833f4d6664159a596c3c361be">More...</a><br/></td></tr>
<tr class="separator:a8d49f96833f4d6664159a596c3c361be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61c9b5aa7cec8e777974e6394ae3a9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorDeque.html#af61c9b5aa7cec8e777974e6394ae3a9b">insert</a> (const DataType &amp;element, const <a class="el" href="classVectorDeque.html#a5cfe4fc61668a1213c99e052450297e6">ConstIterator</a> &amp;it)</td></tr>
<tr class="memdesc:af61c9b5aa7cec8e777974e6394ae3a9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert <code>element</code> before the element pointed to by <code>it</code>.  <a href="#af61c9b5aa7cec8e777974e6394ae3a9b">More...</a><br/></td></tr>
<tr class="separator:af61c9b5aa7cec8e777974e6394ae3a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fac11287907b1e659602e834e402141"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorDeque.html#a2fac11287907b1e659602e834e402141">insert</a> (const DataType &amp;element, const <a class="el" href="classVectorDeque.html#a291aa5e53d483276367327acb93f3846">ConstReverseIterator</a> &amp;it)</td></tr>
<tr class="memdesc:a2fac11287907b1e659602e834e402141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert <code>element</code> after (with respect to <code>*this</code>) the element pointed to by the reverse iterator <code>it</code>.  <a href="#a2fac11287907b1e659602e834e402141">More...</a><br/></td></tr>
<tr class="separator:a2fac11287907b1e659602e834e402141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2276eec2f96514a9f715f2c7baeb9f85"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorDeque.html#a2276eec2f96514a9f715f2c7baeb9f85">isEmpty</a> () const   throw ()</td></tr>
<tr class="memdesc:a2276eec2f96514a9f715f2c7baeb9f85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <code>*this</code> is empty.  <a href="#a2276eec2f96514a9f715f2c7baeb9f85">More...</a><br/></td></tr>
<tr class="separator:a2276eec2f96514a9f715f2c7baeb9f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422235687c4f419d99f6a542bdf9b0e1"><td class="memItemLeft" align="right" valign="top">DataType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorDeque.html#a422235687c4f419d99f6a542bdf9b0e1">peek</a> () const </td></tr>
<tr class="memdesc:a422235687c4f419d99f6a542bdf9b0e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first element of <code>*this</code>.  <a href="#a422235687c4f419d99f6a542bdf9b0e1">More...</a><br/></td></tr>
<tr class="separator:a422235687c4f419d99f6a542bdf9b0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2901d12f640144868d9c3aaee93609f"><td class="memItemLeft" align="right" valign="top">DataType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorDeque.html#ae2901d12f640144868d9c3aaee93609f">peekLast</a> () const </td></tr>
<tr class="memdesc:ae2901d12f640144868d9c3aaee93609f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last element of <code>*this</code>.  <a href="#ae2901d12f640144868d9c3aaee93609f">More...</a><br/></td></tr>
<tr class="separator:ae2901d12f640144868d9c3aaee93609f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c64607e5255a154d4e0e781a9f4cbca"><td class="memItemLeft" align="right" valign="top">DataType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorDeque.html#a2c64607e5255a154d4e0e781a9f4cbca">pop</a> ()</td></tr>
<tr class="memdesc:a2c64607e5255a154d4e0e781a9f4cbca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove and return the first element.  <a href="#a2c64607e5255a154d4e0e781a9f4cbca">More...</a><br/></td></tr>
<tr class="separator:a2c64607e5255a154d4e0e781a9f4cbca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d37b26fef424fc1c7799bded9d0fd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorDeque.html#ab5d37b26fef424fc1c7799bded9d0fd6">popAll</a> (DataType *const target)  throw ()</td></tr>
<tr class="memdesc:ab5d37b26fef424fc1c7799bded9d0fd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put every element into <code>target</code> and then remove them from <code>*this</code>.  <a href="#ab5d37b26fef424fc1c7799bded9d0fd6">More...</a><br/></td></tr>
<tr class="separator:ab5d37b26fef424fc1c7799bded9d0fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7bfa0aed49323c8de6a80f11bc5fd81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorDeque.html#ac7bfa0aed49323c8de6a80f11bc5fd81">popAllLast</a> (DataType *const target)  throw ()</td></tr>
<tr class="memdesc:ac7bfa0aed49323c8de6a80f11bc5fd81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put every element into <code>target</code> from the back and then remove them from <code>*this</code>.  <a href="#ac7bfa0aed49323c8de6a80f11bc5fd81">More...</a><br/></td></tr>
<tr class="separator:ac7bfa0aed49323c8de6a80f11bc5fd81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a109e2ed17317d2b915dfb698148ab"><td class="memItemLeft" align="right" valign="top">DataType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorDeque.html#a66a109e2ed17317d2b915dfb698148ab">popLast</a> ()</td></tr>
<tr class="memdesc:a66a109e2ed17317d2b915dfb698148ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove and return the last element.  <a href="#a66a109e2ed17317d2b915dfb698148ab">More...</a><br/></td></tr>
<tr class="separator:a66a109e2ed17317d2b915dfb698148ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b2be5c47040434600596e408dd56d31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorDeque.html#a7b2be5c47040434600596e408dd56d31">popSome</a> (DataType *const target, const size_t amount)</td></tr>
<tr class="memdesc:a7b2be5c47040434600596e408dd56d31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove <code>amount</code> elements and put them into <code>target</code>.  <a href="#a7b2be5c47040434600596e408dd56d31">More...</a><br/></td></tr>
<tr class="separator:a7b2be5c47040434600596e408dd56d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3767c6a3236b083c025933c6305c138"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorDeque.html#ae3767c6a3236b083c025933c6305c138">popSomeLast</a> (DataType *const target, const size_t amount)</td></tr>
<tr class="memdesc:ae3767c6a3236b083c025933c6305c138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove <code>amount</code> elements from the back and put them into <code>target</code>.  <a href="#ae3767c6a3236b083c025933c6305c138">More...</a><br/></td></tr>
<tr class="separator:ae3767c6a3236b083c025933c6305c138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5afe7cf117463ba11ee7745b92fdd58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVectorDeque.html#a6c7645ed21181c82fd1837362a1e5145">ReverseIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorDeque.html#ab5afe7cf117463ba11ee7745b92fdd58">rbegin</a> ()  throw ()</td></tr>
<tr class="memdesc:ab5afe7cf117463ba11ee7745b92fdd58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reverse iterator pointing to the last element of <code>*this</code>.  <a href="#ab5afe7cf117463ba11ee7745b92fdd58">More...</a><br/></td></tr>
<tr class="separator:ab5afe7cf117463ba11ee7745b92fdd58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7afdc8063b945a6e10d2bee8781340a6"><td class="memItemLeft" align="right" valign="top">DataType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorDeque.html#a7afdc8063b945a6e10d2bee8781340a6">removeAt</a> (const size_t index)</td></tr>
<tr class="memdesc:a7afdc8063b945a6e10d2bee8781340a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the element at <code>index</code>.  <a href="#a7afdc8063b945a6e10d2bee8781340a6">More...</a><br/></td></tr>
<tr class="separator:a7afdc8063b945a6e10d2bee8781340a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6143f275084ea8cd415304b290f5f47c"><td class="memItemLeft" align="right" valign="top">DataType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorDeque.html#a6143f275084ea8cd415304b290f5f47c">removeAt</a> (const <a class="el" href="classVectorDeque.html#a5cfe4fc61668a1213c99e052450297e6">ConstIterator</a> &amp;it)</td></tr>
<tr class="memdesc:a6143f275084ea8cd415304b290f5f47c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the element pointed to by <code>it</code>.  <a href="#a6143f275084ea8cd415304b290f5f47c">More...</a><br/></td></tr>
<tr class="separator:a6143f275084ea8cd415304b290f5f47c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb1308e947cb511882ec495fe0dc45ad"><td class="memItemLeft" align="right" valign="top">DataType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorDeque.html#aeb1308e947cb511882ec495fe0dc45ad">removeAt</a> (const <a class="el" href="classVectorDeque.html#a291aa5e53d483276367327acb93f3846">ConstReverseIterator</a> &amp;it)</td></tr>
<tr class="memdesc:aeb1308e947cb511882ec495fe0dc45ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the element pointed to by <code>it</code>.  <a href="#aeb1308e947cb511882ec495fe0dc45ad">More...</a><br/></td></tr>
<tr class="separator:aeb1308e947cb511882ec495fe0dc45ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d81f4679c64e02d184da597ad5aca6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVectorDeque.html#a14c9e8124611465c5aec6687b9c18a4b">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorDeque.html#a07d81f4679c64e02d184da597ad5aca6">rend</a> ()  throw ()</td></tr>
<tr class="memdesc:a07d81f4679c64e02d184da597ad5aca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator past the last element of <code>*this</code>.  <a href="#a07d81f4679c64e02d184da597ad5aca6">More...</a><br/></td></tr>
<tr class="separator:a07d81f4679c64e02d184da597ad5aca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab006987576c67f39bc5af16cb0b9a5a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorDeque.html#ab006987576c67f39bc5af16cb0b9a5a2">reverseCopyToArray</a> (DataType *const target) const   throw ()</td></tr>
<tr class="memdesc:ab006987576c67f39bc5af16cb0b9a5a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the contents of <code>*this</code> to the given array in reverse order.  <a href="#ab006987576c67f39bc5af16cb0b9a5a2">More...</a><br/></td></tr>
<tr class="separator:ab006987576c67f39bc5af16cb0b9a5a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab43900b93057928ddaea200bc583a3d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorDeque.html#ab43900b93057928ddaea200bc583a3d5">reverseSliceToArray</a> (DataType *const target, const size_t from, const size_t until) const </td></tr>
<tr class="memdesc:ab43900b93057928ddaea200bc583a3d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a slice of contents of <code>*this</code> to <code>target</code> in reverse order.  <a href="#ab43900b93057928ddaea200bc583a3d5">More...</a><br/></td></tr>
<tr class="separator:ab43900b93057928ddaea200bc583a3d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4828ab569807385baf1fcf952dd0ef13"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorDeque.html#a4828ab569807385baf1fcf952dd0ef13">size</a> () const   throw ()</td></tr>
<tr class="memdesc:a4828ab569807385baf1fcf952dd0ef13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in <code>*this</code>.  <a href="#a4828ab569807385baf1fcf952dd0ef13">More...</a><br/></td></tr>
<tr class="separator:a4828ab569807385baf1fcf952dd0ef13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e49c7ef2d032ef574af95129a7f959"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorDeque.html#ad4e49c7ef2d032ef574af95129a7f959">skip</a> (const size_t amount=1)</td></tr>
<tr class="memdesc:ad4e49c7ef2d032ef574af95129a7f959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes <code>amount</code> elements from the front of <code>*this</code>.  <a href="#ad4e49c7ef2d032ef574af95129a7f959">More...</a><br/></td></tr>
<tr class="separator:ad4e49c7ef2d032ef574af95129a7f959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09dc2bf1fcac2a1847de7294b45736e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorDeque.html#a09dc2bf1fcac2a1847de7294b45736e8">skipLast</a> (const size_t amount=1)</td></tr>
<tr class="memdesc:a09dc2bf1fcac2a1847de7294b45736e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes <code>amount</code> elements from the back of <code>*this</code>.  <a href="#a09dc2bf1fcac2a1847de7294b45736e8">More...</a><br/></td></tr>
<tr class="separator:a09dc2bf1fcac2a1847de7294b45736e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a410696c868fd1b4adbe08875c65cf98d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorDeque.html#a410696c868fd1b4adbe08875c65cf98d">sliceToArray</a> (DataType *const target, const size_t from, const size_t until) const </td></tr>
<tr class="memdesc:a410696c868fd1b4adbe08875c65cf98d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a slice of elements of <code>*this</code> to <code>target</code>.  <a href="#a410696c868fd1b4adbe08875c65cf98d">More...</a><br/></td></tr>
<tr class="separator:a410696c868fd1b4adbe08875c65cf98d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a932a7ea50f88f46a0d4038370685414c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a932a7ea50f88f46a0d4038370685414c"></a>
static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorDeque.html#a932a7ea50f88f46a0d4038370685414c">DEFAULT_INITIAL_CAPACITY</a> = 11</td></tr>
<tr class="memdesc:a932a7ea50f88f46a0d4038370685414c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The capacity to initialize a <code><a class="el" href="classVectorDeque.html" title="VectorDeque satisfies the resource constraints typically expected of both Vectors and Deques...">VectorDeque</a></code> to by default. <br/></td></tr>
<tr class="separator:a932a7ea50f88f46a0d4038370685414c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a6999d3f9756fe7f4567fe88f141d471b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6999d3f9756fe7f4567fe88f141d471b"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>VectorDequeTest</b></td></tr>
<tr class="separator:a6999d3f9756fe7f4567fe88f141d471b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class DataType&gt;<br/>
class VectorDeque&lt; DataType &gt;</h3>

<p><code><a class="el" href="classVectorDeque.html" title="VectorDeque satisfies the resource constraints typically expected of both Vectors and Deques...">VectorDeque</a></code> satisfies the resource constraints typically expected of both Vectors and Deques. </p>
<p>In particular, it has</p>
<ul>
<li><code>O(1)</code> Member access</li>
<li><code>O(1)</code> Append</li>
<li><code>O(1)</code> Prepend</li>
</ul>
<p>Additionally, <code><a class="el" href="classVectorDeque.html" title="VectorDeque satisfies the resource constraints typically expected of both Vectors and Deques...">VectorDeque</a></code> will only automatically resize when it is at full capacity. Iterators for <code><a class="el" href="classVectorDeque.html" title="VectorDeque satisfies the resource constraints typically expected of both Vectors and Deques...">VectorDeque</a></code> maintain an index to the element they are currently pointing to, and modifications to the <code><a class="el" href="classVectorDeque.html" title="VectorDeque satisfies the resource constraints typically expected of both Vectors and Deques...">VectorDeque</a></code> will not change that index. For example, suppose an element is added to the front of the <code><a class="el" href="classVectorDeque.html" title="VectorDeque satisfies the resource constraints typically expected of both Vectors and Deques...">VectorDeque</a></code> while an iterator is pointing to the third element. That iterator will now be pointing to what was previously the second element, since that element is now the third element and the iterator's index did not change. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DataType</td><td>The type of the data to contain. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a6ccd352013e04ac9b27651028481ff9c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorDeque.html">VectorDeque</a>&lt; DataType &gt;::<a class="el" href="classVectorDeque.html">VectorDeque</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <code><a class="el" href="classVectorDeque.html" title="VectorDeque satisfies the resource constraints typically expected of both Vectors and Deques...">VectorDeque</a></code> with a default initial capacity. </p>
<p>Runtime: <code>O(1)</code> </p>

</div>
</div>
<a class="anchor" id="a77d6b83cb5d9fb65d6ac1ddfa6833205"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorDeque.html">VectorDeque</a>&lt; DataType &gt;::<a class="el" href="classVectorDeque.html">VectorDeque</a> </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td></td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <code><a class="el" href="classVectorDeque.html" title="VectorDeque satisfies the resource constraints typically expected of both Vectors and Deques...">VectorDeque</a></code> with the given initial capacity. </p>
<p>Runtime: <code>O(1)</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>Initial capacity to construct with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae86351d1ecec0183193144844518a971"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorDeque.html">VectorDeque</a>&lt; DataType &gt;::<a class="el" href="classVectorDeque.html">VectorDeque</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorDeque.html">VectorDeque</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>that</em></td><td>)</td>
          <td></td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-temporary copy constructor. </p>
<p>Differs from the temporary copy constructor in that the underlying array is copied instead of moved. Runtime: <code>O(that.size())</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">that</td><td><code><a class="el" href="classVectorDeque.html" title="VectorDeque satisfies the resource constraints typically expected of both Vectors and Deques...">VectorDeque</a></code> to construct from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa05f563b1148c66067be9a796cfaed13"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorDeque.html">VectorDeque</a>&lt; DataType &gt;::<a class="el" href="classVectorDeque.html">VectorDeque</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorDeque.html">VectorDeque</a>&lt; DataType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>that</em></td><td>)</td>
          <td></td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Temporary copy constructor. </p>
<p>Differs from the non-temporary copy constructor in the the underlying array is moved instead of copied. Runtime: <code>O(1)</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">that</td><td>Temporary <code><a class="el" href="classVectorDeque.html" title="VectorDeque satisfies the resource constraints typically expected of both Vectors and Deques...">VectorDeque</a></code> to construct from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a6627a3c5f96e0a597ca4b497789e2dbb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVectorDeque.html">VectorDeque</a>&lt; DataType &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const DataType &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add <code>element</code> to the back of <code>*this</code>. </p>
<p>Runtime: <code>O(1)</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>Element to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac600744ac03b32391ce2b3326811944f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVectorDeque.html">VectorDeque</a>&lt; DataType &gt;::addAll </td>
          <td>(</td>
          <td class="paramtype">const DataType *const&#160;</td>
          <td class="paramname"><em>elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an array of elements to the back of <code>*this</code>. </p>
<p>Runtime: <code>O(length)</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elements</td><td>Elements to add. </td></tr>
    <tr><td class="paramname">length</td><td>Amount of elements to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a146d4e11742a18062ea3e9e8dd75769f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<div class="memtemplate">
template&lt;class IteratorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVectorDeque.html">VectorDeque</a>&lt; DataType &gt;::addAll </td>
          <td>(</td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a collection of elements to the back of <code>*this</code>. </p>
<p>Runtime: <code>O(size of given collection)</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Iterator to the first element to add. </td></tr>
    <tr><td class="paramname">end</td><td>Iterator past the last element to add. </td></tr>
    <tr><td class="paramname">IteratorType</td><td>The type of the iterator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a97fd51c98bfeccbaf7b5fa24c3ca2f42"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVectorDeque.html">VectorDeque</a>&lt; DataType &gt;::addAllFirst </td>
          <td>(</td>
          <td class="paramtype">const DataType *const&#160;</td>
          <td class="paramname"><em>elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an array of elements to the front of <code>*this</code>. </p>
<p>This method works as though <code>addFirst</code> was sequentially called on <code>elements</code>. Thus, the last element added is the first element in <code>*this</code> after <code>addAllFirst</code> terminates. Runtime: <code>O(length)</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elements</td><td>Elements to add. </td></tr>
    <tr><td class="paramname">length</td><td>Amount of elements to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afe87b9cd1769bb101cc024f8f7883502"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<div class="memtemplate">
template&lt;class IteratorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVectorDeque.html">VectorDeque</a>&lt; DataType &gt;::addAllFirst </td>
          <td>(</td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a collection of elements to the front of <code>*this</code>. </p>
<p>This method works as though <code>addFirst</code> was sequentially called on for the given iterator. Thus, the last element added is the first element in <code>*this</code> after <code>addAllFirst</code> terminates. Runtime: <code>O(size of given collection)</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Iterator to the first element to add. </td></tr>
    <tr><td class="paramname">end</td><td>Iterator past the last element to add. </td></tr>
    <tr><td class="paramname">IteratorType</td><td>The type of the iterator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af28118e77d946e21445f460ca951d983"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVectorDeque.html">VectorDeque</a>&lt; DataType &gt;::addFirst </td>
          <td>(</td>
          <td class="paramtype">const DataType &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add <code>element</code> to the front of <code>*this</code>. </p>
<p>Runtime: <code>O(1)</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>Element to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2f16427750643789ac9bddc8337ec702"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorDeque.html#a14c9e8124611465c5aec6687b9c18a4b">Iterator</a> <a class="el" href="classVectorDeque.html">VectorDeque</a>&lt; DataType &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator pointing to the first element of <code>*this</code>. </p>
<p>Runtime: <code>O(1)</code> </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element of <code>*this</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ab50b3786dae9b81ebd8938e6e70bb02e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorDeque.html#a5cfe4fc61668a1213c99e052450297e6">ConstIterator</a> <a class="el" href="classVectorDeque.html">VectorDeque</a>&lt; DataType &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a constant iterator pointing to the first element of <code>*this</code>. </p>
<p>Runtime: <code>O(1)</code> </p>
<dl class="section return"><dt>Returns</dt><dd>Constant iterator pointing to the first element of <code>*this</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a77f86389895243f392ceabe443203e32"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorDeque.html#a5cfe4fc61668a1213c99e052450297e6">ConstIterator</a> <a class="el" href="classVectorDeque.html">VectorDeque</a>&lt; DataType &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator past the last element of <code>*this</code>. </p>
<p>Runtime: <code>O(1)</code> </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator past the last element of <code>*this</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="afac9474353f64902fccb648c537e652f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVectorDeque.html">VectorDeque</a>&lt; DataType &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove all elements from <code>*this</code>. </p>
<p>Runtime: <code>O(1)</code>. </p>

</div>
</div>
<a class="anchor" id="ae0cbf3779a0ea9be8bbfd2409eba889f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classVectorDeque.html">VectorDeque</a>&lt; DataType &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const DataType &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td> const</td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check to see if <code>element</code> is contained in <code>*this</code>. </p>
<p>Runtime: <code>O(size())</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>Element to check for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> If <code>(*this)[i] == element</code> for some <code>0 &lt;= i &lt; <a class="el" href="classVectorDeque.html#a4828ab569807385baf1fcf952dd0ef13" title="Returns the number of elements in *this. ">size()</a></code> and <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a42a1250984dcf602e225ecbe10d7cfc9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVectorDeque.html">VectorDeque</a>&lt; DataType &gt;::copyToArray </td>
          <td>(</td>
          <td class="paramtype">DataType *const&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td> const</td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the contents of <code>*this</code> to <code>target</code>. </p>
<p>Runtime: <code>O(size())</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Array to copy to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6577db57d37cc36ce00060baa2abfef6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorDeque.html#a291aa5e53d483276367327acb93f3846">ConstReverseIterator</a> <a class="el" href="classVectorDeque.html">VectorDeque</a>&lt; DataType &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a constant reverse iterator pointing to the last element of <code>*this</code>. </p>
<p>Runtime: <code>O(1)</code> </p>
<dl class="section return"><dt>Returns</dt><dd>Constant reverse iterator pointing to the last element of <code>*this</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="abac13f397fa78185ae34fc14751ab720"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorDeque.html#a291aa5e53d483276367327acb93f3846">ConstReverseIterator</a> <a class="el" href="classVectorDeque.html">VectorDeque</a>&lt; DataType &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator past the last element of <code>*this</code>. </p>
<p>Runtime: <code>O(1)</code> </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator past the last element of <code>*this</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a3fe1250d2f55a3208ac1a2c8597ca4ed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorDeque.html#a14c9e8124611465c5aec6687b9c18a4b">Iterator</a> <a class="el" href="classVectorDeque.html">VectorDeque</a>&lt; DataType &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator past the last element of <code>*this</code>. </p>
<p>Runtime: <code>O(1)</code> </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator past the last element of <code>*this</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a301ac89ba3198559c65bd7ff18f4b107"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t <a class="el" href="classVectorDeque.html">VectorDeque</a>&lt; DataType &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const DataType &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td> const</td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check to see where <code>element</code> is located in <code>*this</code>. </p>
<p>Runtime: <code>O(size())</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>Element to check for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first <code>i</code> such that <code>(</code>*this<code>)[i] == element</code> or <code>-1</code> if no such element exists. </dd></dl>

</div>
</div>
<a class="anchor" id="a1685429a5556997348d6cf155f499fcd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DataType&amp; <a class="el" href="classVectorDeque.html">VectorDeque</a>&lt; DataType &gt;::fromBack </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the element at <code>index</code> starting from the last element. </p>
<p>Runtime: <code>O(1)</code> Exception Safety: Strong </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index to get an element at. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the element. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>If <code>index &gt;= <a class="el" href="classVectorDeque.html#a4828ab569807385baf1fcf952dd0ef13" title="Returns the number of elements in *this. ">size()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8d49f96833f4d6664159a596c3c361be"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVectorDeque.html">VectorDeque</a>&lt; DataType &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const DataType &amp;&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>before</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert <code>element</code> before <code>before</code>. </p>
<p>Runtime: Amortized <code>O(min(before, <a class="el" href="classVectorDeque.html#a4828ab569807385baf1fcf952dd0ef13" title="Returns the number of elements in *this. ">size()</a> - before))</code> Exception Safety: Strong </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>Element to insert. </td></tr>
    <tr><td class="paramname">before</td><td>Index of the element to insert before. The inserted element's index will be <code>before</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>If <code>before &gt; <a class="el" href="classVectorDeque.html#a4828ab569807385baf1fcf952dd0ef13" title="Returns the number of elements in *this. ">size()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af61c9b5aa7cec8e777974e6394ae3a9b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVectorDeque.html">VectorDeque</a>&lt; DataType &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const DataType &amp;&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorDeque.html#a5cfe4fc61668a1213c99e052450297e6">ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert <code>element</code> before the element pointed to by <code>it</code>. </p>
<p>If the call is successful, the iterator will be pointing to the new element. Runtime: <code>O(size())</code> Exception Safety: Strong </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>Iterator whose pointed-to element will be after the inserted element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>If <code>it</code> points to an out-of-bounds element. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>If <code>it</code> is not iterating over <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2fac11287907b1e659602e834e402141"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVectorDeque.html">VectorDeque</a>&lt; DataType &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const DataType &amp;&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorDeque.html#a291aa5e53d483276367327acb93f3846">ConstReverseIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert <code>element</code> after (with respect to <code>*this</code>) the element pointed to by the reverse iterator <code>it</code>. </p>
<p>If the call is successful, the iterator will be pointing to the new element. Runtime: <code>O(size())</code> Exception Safety: Strong </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>Iterator whose pointed-to element will be after the inserted element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>If <code>it</code> points to an out-of-bounds element. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>If <code>it</code> is not iterating over <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2276eec2f96514a9f715f2c7baeb9f85"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classVectorDeque.html">VectorDeque</a>&lt; DataType &gt;::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether <code>*this</code> is empty. </p>
<p>Runtime: <code>O(1)</code> </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> If <code><a class="el" href="classVectorDeque.html#a4828ab569807385baf1fcf952dd0ef13" title="Returns the number of elements in *this. ">size()</a> == 0</code>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a77f1a6f951f10d2dbb0a2d4ab37d3df1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorDeque.html">VectorDeque</a>&lt; DataType &gt;::operator std::string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives a human-readable representation of <code>*this</code>. </p>
<p>Runtime: <code>O(size())</code> </p>
<dl class="section return"><dt>Returns</dt><dd>Each element of <code>*this</code>, comma-separated and enclosed in curly braces. </dd></dl>

</div>
</div>
<a class="anchor" id="ab14f8f936e72e47a71b6345b6e2ee5b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classVectorDeque.html">VectorDeque</a>&lt; DataType &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorDeque.html">VectorDeque</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>that</em></td><td>)</td>
          <td> const</td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks to see if <code>*this</code> is not equal to another <a class="el" href="classVectorDeque.html" title="VectorDeque satisfies the resource constraints typically expected of both Vectors and Deques...">VectorDeque</a>. </p>
<p>Runtime: <code>O(size())</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">that</td><td>Other <code><a class="el" href="classVectorDeque.html" title="VectorDeque satisfies the resource constraints typically expected of both Vectors and Deques...">VectorDeque</a></code> to check inequality for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> If <code>(*this)[i] != that[i]</code> for some <code>0 &lt;= i &lt; <a class="el" href="classVectorDeque.html#a4828ab569807385baf1fcf952dd0ef13" title="Returns the number of elements in *this. ">size()</a></code> or <code>this-&gt;<a class="el" href="classVectorDeque.html#a4828ab569807385baf1fcf952dd0ef13" title="Returns the number of elements in *this. ">size()</a> != that.size()</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a8be7a91c8d970e4dacce3500116b6f06"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorDeque.html">VectorDeque</a>&amp; <a class="el" href="classVectorDeque.html">VectorDeque</a>&lt; DataType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorDeque.html">VectorDeque</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>that</em></td><td>)</td>
          <td></td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-temporary assignment. </p>
<p>Differs from temporary assignment in that the underlying array is copied instead of moved. Runtime: <code>O(that.size())</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">that</td><td><code><a class="el" href="classVectorDeque.html" title="VectorDeque satisfies the resource constraints typically expected of both Vectors and Deques...">VectorDeque</a></code> to assign from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>*this</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a80a42da54a15e4f0b4e9f9430e2278a2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorDeque.html">VectorDeque</a>&amp; <a class="el" href="classVectorDeque.html">VectorDeque</a>&lt; DataType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorDeque.html">VectorDeque</a>&lt; DataType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>that</em></td><td>)</td>
          <td></td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Temporary assignment. </p>
<p>Differs from the non-temporary assignment in the the underlying array is moved instead of copied. Runtime: <code>O(1)</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">that</td><td>Temporary <code><a class="el" href="classVectorDeque.html" title="VectorDeque satisfies the resource constraints typically expected of both Vectors and Deques...">VectorDeque</a></code> to assign from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>*this</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a0595132279942b754d035d1e2fedbacb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classVectorDeque.html">VectorDeque</a>&lt; DataType &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorDeque.html">VectorDeque</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>that</em></td><td>)</td>
          <td> const</td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks to see if <code>*this</code> is equal to another <code><a class="el" href="classVectorDeque.html" title="VectorDeque satisfies the resource constraints typically expected of both Vectors and Deques...">VectorDeque</a></code>. </p>
<p>Runtime:<code>O(size())</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">that</td><td>Other <code><a class="el" href="classVectorDeque.html" title="VectorDeque satisfies the resource constraints typically expected of both Vectors and Deques...">VectorDeque</a></code> to check equality for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If <code>(*this)[i] == that[i]</code> for every <code>0 &lt;= i &lt; <a class="el" href="classVectorDeque.html#a4828ab569807385baf1fcf952dd0ef13" title="Returns the number of elements in *this. ">size()</a></code> and <code>this-&gt;<a class="el" href="classVectorDeque.html#a4828ab569807385baf1fcf952dd0ef13" title="Returns the number of elements in *this. ">size()</a> == that.size()</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a1c554dd6085326d0054c32736059654a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DataType&amp; <a class="el" href="classVectorDeque.html">VectorDeque</a>&lt; DataType &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the element at <code>index</code>. </p>
<p>Runtime: <code>O(1)</code> Exception Safety: Strong </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index to get an element at. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the element. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>If <code>index &gt;= <a class="el" href="classVectorDeque.html#a4828ab569807385baf1fcf952dd0ef13" title="Returns the number of elements in *this. ">size()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a422235687c4f419d99f6a542bdf9b0e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DataType <a class="el" href="classVectorDeque.html">VectorDeque</a>&lt; DataType &gt;::peek </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the first element of <code>*this</code>. </p>
<p>Runtime: <code>O(1)</code> Exception Safety: Strong </p>
<dl class="section return"><dt>Returns</dt><dd>The first element of <code>*this</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>If <code><a class="el" href="classVectorDeque.html#a2276eec2f96514a9f715f2c7baeb9f85" title="Checks whether *this is empty. ">isEmpty()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae2901d12f640144868d9c3aaee93609f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DataType <a class="el" href="classVectorDeque.html">VectorDeque</a>&lt; DataType &gt;::peekLast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the last element of <code>*this</code>. </p>
<p>Runtime: <code>O(1)</code> Exception Safety: Strong </p>
<dl class="section return"><dt>Returns</dt><dd>The last element of <code>*this</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>If <code><a class="el" href="classVectorDeque.html#a2276eec2f96514a9f715f2c7baeb9f85" title="Checks whether *this is empty. ">isEmpty()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2c64607e5255a154d4e0e781a9f4cbca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DataType <a class="el" href="classVectorDeque.html">VectorDeque</a>&lt; DataType &gt;::pop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove and return the first element. </p>
<p>Runtime: <code>O(1)</code> Exception Safety: Strong </p>
<dl class="section return"><dt>Returns</dt><dd>The first element. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>If <code><a class="el" href="classVectorDeque.html#a2276eec2f96514a9f715f2c7baeb9f85" title="Checks whether *this is empty. ">isEmpty()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab5d37b26fef424fc1c7799bded9d0fd6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVectorDeque.html">VectorDeque</a>&lt; DataType &gt;::popAll </td>
          <td>(</td>
          <td class="paramtype">DataType *const&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Put every element into <code>target</code> and then remove them from <code>*this</code>. </p>
<p>Runtime: <code>O(size())</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Array to put elements into. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac7bfa0aed49323c8de6a80f11bc5fd81"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVectorDeque.html">VectorDeque</a>&lt; DataType &gt;::popAllLast </td>
          <td>(</td>
          <td class="paramtype">DataType *const&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Put every element into <code>target</code> from the back and then remove them from <code>*this</code>. </p>
<p>Runtime: <code>O(size())</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Array to put elements into. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a66a109e2ed17317d2b915dfb698148ab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DataType <a class="el" href="classVectorDeque.html">VectorDeque</a>&lt; DataType &gt;::popLast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove and return the last element. </p>
<p>Runtime: <code>O(1)</code> Exception Safety: Strong </p>
<dl class="section return"><dt>Returns</dt><dd>The last element. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>If <a class="el" href="classVectorDeque.html#a2276eec2f96514a9f715f2c7baeb9f85" title="Checks whether *this is empty. ">isEmpty()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7b2be5c47040434600596e408dd56d31"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVectorDeque.html">VectorDeque</a>&lt; DataType &gt;::popSome </td>
          <td>(</td>
          <td class="paramtype">DataType *const&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>amount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove <code>amount</code> elements and put them into <code>target</code>. </p>
<p>Runtime: <code>O(amount)</code> Exception Safety: Strong </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Array to put removed elements into. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>If <code><a class="el" href="classVectorDeque.html#a4828ab569807385baf1fcf952dd0ef13" title="Returns the number of elements in *this. ">size()</a> &lt; amount</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae3767c6a3236b083c025933c6305c138"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVectorDeque.html">VectorDeque</a>&lt; DataType &gt;::popSomeLast </td>
          <td>(</td>
          <td class="paramtype">DataType *const&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>amount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove <code>amount</code> elements from the back and put them into <code>target</code>. </p>
<p>This method works as if <code>amount</code> invocations of <code>popLast</code> were sequentially called on <code>*this</code>. Thus, the last element popped will be the last element in <code>target</code>. Runtime: <code>O(amount)</code> Exception Safety: Strong </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Array to put removed elements into. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>If <code><a class="el" href="classVectorDeque.html#a4828ab569807385baf1fcf952dd0ef13" title="Returns the number of elements in *this. ">size()</a> &lt; amount</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab5afe7cf117463ba11ee7745b92fdd58"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorDeque.html#a6c7645ed21181c82fd1837362a1e5145">ReverseIterator</a> <a class="el" href="classVectorDeque.html">VectorDeque</a>&lt; DataType &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reverse iterator pointing to the last element of <code>*this</code>. </p>
<p>Runtime: <code>O(1)</code> </p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator pointing to the first element of <code>*this</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a7afdc8063b945a6e10d2bee8781340a6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DataType <a class="el" href="classVectorDeque.html">VectorDeque</a>&lt; DataType &gt;::removeAt </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the element at <code>index</code>. </p>
<p>Runtime: <code>O(size())</code> Exception Safety: Strong </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index to remove the element at. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The removed element. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>If <code>index &gt;= <a class="el" href="classVectorDeque.html#a4828ab569807385baf1fcf952dd0ef13" title="Returns the number of elements in *this. ">size()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6143f275084ea8cd415304b290f5f47c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DataType <a class="el" href="classVectorDeque.html">VectorDeque</a>&lt; DataType &gt;::removeAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorDeque.html#a5cfe4fc61668a1213c99e052450297e6">ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the element pointed to by <code>it</code>. </p>
<p>Runtime: <code>O(size())</code> Exception Safety: Strong </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>Iterator to remove the pointed-to element for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The removed element. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>If <code>it</code> points to an out-of-bounds element. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>If <code>it</code> is not iterating over <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeb1308e947cb511882ec495fe0dc45ad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DataType <a class="el" href="classVectorDeque.html">VectorDeque</a>&lt; DataType &gt;::removeAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorDeque.html#a291aa5e53d483276367327acb93f3846">ConstReverseIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the element pointed to by <code>it</code>. </p>
<p>Runtime: <code>O(size())</code> Exception Safety: Strong </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>Iterator to remove the pointed-to element for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The removed element. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>If <code>it</code> points to an out-of-bounds element. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>If <code>it</code> is not iterating over <code>*this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a07d81f4679c64e02d184da597ad5aca6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorDeque.html#a14c9e8124611465c5aec6687b9c18a4b">Iterator</a> <a class="el" href="classVectorDeque.html">VectorDeque</a>&lt; DataType &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator past the last element of <code>*this</code>. </p>
<p>Runtime: <code>O(1)</code> </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator past the last element of <code>*this</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ab006987576c67f39bc5af16cb0b9a5a2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVectorDeque.html">VectorDeque</a>&lt; DataType &gt;::reverseCopyToArray </td>
          <td>(</td>
          <td class="paramtype">DataType *const&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td> const</td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the contents of <code>*this</code> to the given array in reverse order. </p>
<p>Runtime: <code>O(size())</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Array to copy to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab43900b93057928ddaea200bc583a3d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVectorDeque.html">VectorDeque</a>&lt; DataType &gt;::reverseSliceToArray </td>
          <td>(</td>
          <td class="paramtype">DataType *const&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>until</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy a slice of contents of <code>*this</code> to <code>target</code> in reverse order. </p>
<p>Runtime: <code>O(until - from)</code> Exception Safety: Strong </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Array to copy to. </td></tr>
    <tr><td class="paramname">from</td><td>Index of <code>*this</code> to start copying. </td></tr>
    <tr><td class="paramname">until</td><td>Index of <code>*this</code> to stop copying (exclusive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>If <code>until &gt; <a class="el" href="classVectorDeque.html#a4828ab569807385baf1fcf952dd0ef13" title="Returns the number of elements in *this. ">size()</a></code>. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>If <code>from &gt; until</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4828ab569807385baf1fcf952dd0ef13"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classVectorDeque.html">VectorDeque</a>&lt; DataType &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in <code>*this</code>. </p>
<p>Runtime: <code>O(1)</code> </p>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in <code>*this</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ad4e49c7ef2d032ef574af95129a7f959"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVectorDeque.html">VectorDeque</a>&lt; DataType &gt;::skip </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>amount</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes <code>amount</code> elements from the front of <code>*this</code>. </p>
<p>Runtime: <code>O(1)</code> Exception Safety: Strong </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">amount</td><td>Amount of elements to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>If <code>amount &gt; <a class="el" href="classVectorDeque.html#a4828ab569807385baf1fcf952dd0ef13" title="Returns the number of elements in *this. ">size()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a09dc2bf1fcac2a1847de7294b45736e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVectorDeque.html">VectorDeque</a>&lt; DataType &gt;::skipLast </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>amount</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes <code>amount</code> elements from the back of <code>*this</code>. </p>
<p>Runtime: <code>O(1)</code> Exception Safety: Strong </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">amount</td><td>Amount of elements to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>If <code>amount &gt; <a class="el" href="classVectorDeque.html#a4828ab569807385baf1fcf952dd0ef13" title="Returns the number of elements in *this. ">size()</a></code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a410696c868fd1b4adbe08875c65cf98d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVectorDeque.html">VectorDeque</a>&lt; DataType &gt;::sliceToArray </td>
          <td>(</td>
          <td class="paramtype">DataType *const&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>until</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy a slice of elements of <code>*this</code> to <code>target</code>. </p>
<p>Runtime: <code>O(until - from)</code> Exception Safety: Strong </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Array to copy to. </td></tr>
    <tr><td class="paramname">from</td><td>Index of <code>*this</code> to start copying. </td></tr>
    <tr><td class="paramname">until</td><td>Index of <code>*this</code> to stop copying (exclusive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>If <code>until &gt; <a class="el" href="classVectorDeque.html#a4828ab569807385baf1fcf952dd0ef13" title="Returns the number of elements in *this. ">size()</a></code> or <code>from &gt; until</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>main/include/<a class="el" href="VectorDeque_8hpp_source.html">VectorDeque.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
